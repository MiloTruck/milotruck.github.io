<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.16.6 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>COVID’s Communication Technology! [984] - Home</title>
<meta name="description" content="Category: Internet of Things (IoT)Challenge Description  We heard a rumor that COVID was leveraging that smart city’s ‘light’ technology for communication. Find out in detail on the technology and what is being transmitted.Initial AnalysisWe are given a .logicdata file. After some research, we find that it is a capture output from a Saleae logic analyzer. Essentially, the deivce logs the output of digital/analog pins.From the challenge description, we know that it is a communication between 2 devices.Opening the file in the Saleae Logic Analyzer software (hence forth referred to as Saleae), we find that only a single channel/wire is used to transmit data. Note: for .logicdata files, only Saleae version 1 can be used.About Communication ProtocolsIf you are only concerned with the solution and already have some basic knowledge of hardware protocols, feel free to skip this section.Since this challenge is in the IoT category, I figured I should provide a brief background about communication protocols. In order for 2 devices to send data to each other, a protocol has to be established, similar to typical network transmission protocols, but at a hardware level. Usually, the data line is digital (0 or 1). This is true for this challenge as the data being sent is “light communication”.Examples of common protocols are Serial UART and I2C (pronounced I-squared-C). You can read up on them on your own. But most of them have a pretty standard format: header, address (if more than 2 devices), message length, message. This forms the basis of my initial solution.Coming from a robotics background, I am familiar with hardware protocols, even coding one based off the I2C protocol recently. I will discuss 2 key ideas that are seen in many protocols: Clocks and packet structures.In every data transmission, in order to differentiate multiple consecutive bits of the same value (e.g. 1111) a clock is usually established. In systems with more than 1 wire, the clock line (SCL in I2C or CLK) alternates between 0 and 1. Since the system given uses 1 wire, there must be a fixed clock rate, making it easier to read our data as we do not have to worry about rising and falling edges on our clock line.There is also typically a fixed packet structure. In I2C, it is &lt;packet header&gt;&lt;address&gt;&lt;length&gt;&lt;data&gt;  The header can simply be a HIGH signal to start the data transmission  Addresses are used in systems with multiple devices  Length is the string length of the data. Alternatively, some systems may prefer a fixed packet length or a terminator (fixed string to determine end of sequence)My Initial SolutionIf you are uninterested in my failed almost unimportant attempts, skip this section. However, note that skipping this section also assumes you have used the Saleae software before or can figure it out on your own.Of course, the easiest way to start this challenge is to try all the different analyzers (right panel). That didn’t work. So I proceeded to analyze the data packets manually.As seen below, each packet begins with a long HIGH, a long LOW, followed by a sequence of HIGHs and LOWs of fixed width (clock timing has been established). It is interesting to note how a HIGH also has LOWs beside it which does not occur in many protocols.Scrolling in on each HIGH reveals that it is an oscillating signal, making it even harder for certain analyzers to read.Thus, I decided to write a python script to parse the data. The data can be exported to via options &gt; Export data. I assumed the following to be the headers (including addresses): &lt;long HIGH&gt;&lt;long LOW&gt;1111111110101010101010101. Anything after would form the data. I then interpreted the data. For the above image, it would’ve been 101011101010110111. I also assumed a fixed packet length, padding each packet to a multiple of 8 bits. However, converting this to ASCII didn’t work, even if I used a 7-bit ASCII instead.It was at this point I realized my approach was probably wrong. The challenge must be telling something else.The Real SolutionIt dawned upon me that light protocol could refer to an infrared light protocol (NEC IR). I googled about the NEC IR protocol and out came this image.Bingo! This looks EXACTLY like what we are given!In each NEC IR packet, the value of each bit is determined by the time between 2 HIGHs. A long 9ms HIGH and 4.5ms LOW signals the start. Followed by the address and its logical inverse, and then the data and its logical inverse for verification.The Saleae Logic Analyzer software does not officially support the NEC IR protocol so if I wanted to use the software’s analyzer, I would’ve had to download the Saleae SDK and import a library. I also figured that since each “HIGH” contains multiple oscillations of HIGHs and LOWs, this may introduce errors. Instead, we can export the data to a CSV and use a Python script to decode the data whilst ignoring the “noise”.In addition, we notice that the last quarter of the data packets given are not an exact logical inverse of the 3rd quarter. This means the data in our capture does not exactly correspond to the original NEC IR specifications. So perhaps using a script to parse this data is simpler than trying to make an existing analyzer work.Using the Python script below, the bits of the data can be extracted including the headers and addresses. Thresholds for headers and timings between bits could be empirically derived from Saleae in case the transmission does not directly correspond to the original NEC IR specifications.import pandas as pd# Empirically determined timings for 0s and 1szeroTime=0.0005698 oneTime=0.001725df = pd.read_csv(&#39;raw.csv&#39;)outstr = &#39;&#39;prevT = 0prevX = 0prevOne=0first = Truethreshold = (zeroTime+oneTime)/2print &quot;Threshold:&quot;,thresholdfor index, row in df.iterrows():	t = row[&#39;t&#39;]-prevT	if t &gt; 0.0001: #Ignoring noise where gap between 2 HIGHs less than 0.1ms		if t &gt; 0.5: #If gap between 2 HIGHs is more than 500ms, start next packet (ie next line in output string)			if not first: outstr += &#39;\n&#39;					first = False			else:	#When a valid HIGH is detected, determine the value of the bit based on the time between the two			if prevX==0:				outstr+= &#39;1&#39; if t&gt;threshold else &#39;0&#39;	prevT = row[&#39;t&#39;]	prevX = row[&#39;x&#39;]#Save output string to filewith open(&#39;out.txt&#39;,&#39;w&#39;) as f:	f.write(outstr)The output of the above script produces a text file including headers and addresses. The block below only contains one of 6 repeated instances - the message was sent 6.5 times.100000000111111110000000000000000100000000111111110000000000000000100000000111111110110011101101111100000000111111110111011001110100100000000111111110110010101100011100000000111111110110100000101101100000000111111110110001101110011100000000111111110110011101111011100000000111111110100001101010100100000000111111110110011001011111100000000111111110100100101010010100000000111111110101111101001110100000000111111110100010101000011100000000111111110101111100110010100000000111111110011000001000000100000000111111110011000000100001100000000111111110101111101111101Since the address and its logical inverse is consistent throughout (only 1 destination address), the header, address and inverse address can be removed. I used a simple find and replace in a text editor to remove 10000000011111111. The first 2 lines can also be excluded since they are null bytes.011001110110111101110110011101000110010101100011011010000010110101100011011100110110011101111011010000110101010001100110010111110100100101010010010111110100111001000101010000110101111100110010001100000100000000110000001000010101111101111101Copying the above text into a binary to ASCII converter, we obtain the flag govtech-csg{CTf_IR_NEC_20@0!_}, except for an extra ‘_’ which could’ve been added to make the string a multiple of 2 characters.Flag: govtech-csg{CTf_IR_NEC_20@0!}">


  <meta name="author" content="MiloTruck">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Home">
<meta property="og:title" content="COVID’s Communication Technology! [984]">
<meta property="og:url" content="http://localhost:4000/COVID's-Communication-Technology!/">


  <meta property="og:description" content="Category: Internet of Things (IoT)Challenge Description  We heard a rumor that COVID was leveraging that smart city’s ‘light’ technology for communication. Find out in detail on the technology and what is being transmitted.Initial AnalysisWe are given a .logicdata file. After some research, we find that it is a capture output from a Saleae logic analyzer. Essentially, the deivce logs the output of digital/analog pins.From the challenge description, we know that it is a communication between 2 devices.Opening the file in the Saleae Logic Analyzer software (hence forth referred to as Saleae), we find that only a single channel/wire is used to transmit data. Note: for .logicdata files, only Saleae version 1 can be used.About Communication ProtocolsIf you are only concerned with the solution and already have some basic knowledge of hardware protocols, feel free to skip this section.Since this challenge is in the IoT category, I figured I should provide a brief background about communication protocols. In order for 2 devices to send data to each other, a protocol has to be established, similar to typical network transmission protocols, but at a hardware level. Usually, the data line is digital (0 or 1). This is true for this challenge as the data being sent is “light communication”.Examples of common protocols are Serial UART and I2C (pronounced I-squared-C). You can read up on them on your own. But most of them have a pretty standard format: header, address (if more than 2 devices), message length, message. This forms the basis of my initial solution.Coming from a robotics background, I am familiar with hardware protocols, even coding one based off the I2C protocol recently. I will discuss 2 key ideas that are seen in many protocols: Clocks and packet structures.In every data transmission, in order to differentiate multiple consecutive bits of the same value (e.g. 1111) a clock is usually established. In systems with more than 1 wire, the clock line (SCL in I2C or CLK) alternates between 0 and 1. Since the system given uses 1 wire, there must be a fixed clock rate, making it easier to read our data as we do not have to worry about rising and falling edges on our clock line.There is also typically a fixed packet structure. In I2C, it is &lt;packet header&gt;&lt;address&gt;&lt;length&gt;&lt;data&gt;  The header can simply be a HIGH signal to start the data transmission  Addresses are used in systems with multiple devices  Length is the string length of the data. Alternatively, some systems may prefer a fixed packet length or a terminator (fixed string to determine end of sequence)My Initial SolutionIf you are uninterested in my failed almost unimportant attempts, skip this section. However, note that skipping this section also assumes you have used the Saleae software before or can figure it out on your own.Of course, the easiest way to start this challenge is to try all the different analyzers (right panel). That didn’t work. So I proceeded to analyze the data packets manually.As seen below, each packet begins with a long HIGH, a long LOW, followed by a sequence of HIGHs and LOWs of fixed width (clock timing has been established). It is interesting to note how a HIGH also has LOWs beside it which does not occur in many protocols.Scrolling in on each HIGH reveals that it is an oscillating signal, making it even harder for certain analyzers to read.Thus, I decided to write a python script to parse the data. The data can be exported to via options &gt; Export data. I assumed the following to be the headers (including addresses): &lt;long HIGH&gt;&lt;long LOW&gt;1111111110101010101010101. Anything after would form the data. I then interpreted the data. For the above image, it would’ve been 101011101010110111. I also assumed a fixed packet length, padding each packet to a multiple of 8 bits. However, converting this to ASCII didn’t work, even if I used a 7-bit ASCII instead.It was at this point I realized my approach was probably wrong. The challenge must be telling something else.The Real SolutionIt dawned upon me that light protocol could refer to an infrared light protocol (NEC IR). I googled about the NEC IR protocol and out came this image.Bingo! This looks EXACTLY like what we are given!In each NEC IR packet, the value of each bit is determined by the time between 2 HIGHs. A long 9ms HIGH and 4.5ms LOW signals the start. Followed by the address and its logical inverse, and then the data and its logical inverse for verification.The Saleae Logic Analyzer software does not officially support the NEC IR protocol so if I wanted to use the software’s analyzer, I would’ve had to download the Saleae SDK and import a library. I also figured that since each “HIGH” contains multiple oscillations of HIGHs and LOWs, this may introduce errors. Instead, we can export the data to a CSV and use a Python script to decode the data whilst ignoring the “noise”.In addition, we notice that the last quarter of the data packets given are not an exact logical inverse of the 3rd quarter. This means the data in our capture does not exactly correspond to the original NEC IR specifications. So perhaps using a script to parse this data is simpler than trying to make an existing analyzer work.Using the Python script below, the bits of the data can be extracted including the headers and addresses. Thresholds for headers and timings between bits could be empirically derived from Saleae in case the transmission does not directly correspond to the original NEC IR specifications.import pandas as pd# Empirically determined timings for 0s and 1szeroTime=0.0005698 oneTime=0.001725df = pd.read_csv(&#39;raw.csv&#39;)outstr = &#39;&#39;prevT = 0prevX = 0prevOne=0first = Truethreshold = (zeroTime+oneTime)/2print &quot;Threshold:&quot;,thresholdfor index, row in df.iterrows():	t = row[&#39;t&#39;]-prevT	if t &gt; 0.0001: #Ignoring noise where gap between 2 HIGHs less than 0.1ms		if t &gt; 0.5: #If gap between 2 HIGHs is more than 500ms, start next packet (ie next line in output string)			if not first: outstr += &#39;\n&#39;					first = False			else:	#When a valid HIGH is detected, determine the value of the bit based on the time between the two			if prevX==0:				outstr+= &#39;1&#39; if t&gt;threshold else &#39;0&#39;	prevT = row[&#39;t&#39;]	prevX = row[&#39;x&#39;]#Save output string to filewith open(&#39;out.txt&#39;,&#39;w&#39;) as f:	f.write(outstr)The output of the above script produces a text file including headers and addresses. The block below only contains one of 6 repeated instances - the message was sent 6.5 times.100000000111111110000000000000000100000000111111110000000000000000100000000111111110110011101101111100000000111111110111011001110100100000000111111110110010101100011100000000111111110110100000101101100000000111111110110001101110011100000000111111110110011101111011100000000111111110100001101010100100000000111111110110011001011111100000000111111110100100101010010100000000111111110101111101001110100000000111111110100010101000011100000000111111110101111100110010100000000111111110011000001000000100000000111111110011000000100001100000000111111110101111101111101Since the address and its logical inverse is consistent throughout (only 1 destination address), the header, address and inverse address can be removed. I used a simple find and replace in a text editor to remove 10000000011111111. The first 2 lines can also be excluded since they are null bytes.011001110110111101110110011101000110010101100011011010000010110101100011011100110110011101111011010000110101010001100110010111110100100101010010010111110100111001000101010000110101111100110010001100000100000000110000001000010101111101111101Copying the above text into a binary to ASCII converter, we obtain the flag govtech-csg{CTf_IR_NEC_20@0!_}, except for an extra ‘_’ which could’ve been added to make the string a multiple of 2 characters.Flag: govtech-csg{CTf_IR_NEC_20@0!}">







  <meta property="article:published_time" content="2020-12-12T00:00:00+08:00">





  

  


<link rel="canonical" href="http://localhost:4000/COVID's-Communication-Technology!/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "MiloTruck",
      "url": "http://localhost:4000/"
    
  }
</script>


  <meta name="google-site-verification" content="_tE-Yah0HQSRNng0bITIKhyyOoGrbpidFdmZFnKylks" />





<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Home Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/Favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/Favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/Favicon/favicon-16x16.png">
<link rel="manifest" href="/assets/images/Favicon/site.webmanifest">
<link rel="mask-icon" href="/assets/images/Favicon/safari-pinned-tab.svg" color="#636363">
<link rel="shortcut icon" href="/assets/images/Favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#000000">
<meta name="msapplication-config" content="/assets/images/Favicon/browserconfig.xml">
<meta name="theme-color" content="#ffffff">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Home
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about/" >About</a>
            </li><li class="masthead__menu-item">
              <a href="/ctf" >CTF Writeups</a>
            </li><li class="masthead__menu-item">
              <a href="/projects" >Projects</a>
            </li><li class="masthead__menu-item">
              <a href="/blog" >Blog</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/Logo.png" alt="MiloTruck" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">MiloTruck</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Hi. I’m MiloTruck.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Singapore</span>
        </li>
      

      
        
          
        
          
        
          
        
          
            <li><a href="https://github.com/MiloTruck" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="COVID’s Communication Technology! [984]">
    <meta itemprop="description" content="Category: Internet of Things (IoT)Challenge Description  We heard a rumor that COVID was leveraging that smart city’s ‘light’ technology for communication. Find out in detail on the technology and what is being transmitted.Initial AnalysisWe are given a .logicdata file. After some research, we find that it is a capture output from a Saleae logic analyzer. Essentially, the deivce logs the output of digital/analog pins.From the challenge description, we know that it is a communication between 2 devices.Opening the file in the Saleae Logic Analyzer software (hence forth referred to as Saleae), we find that only a single channel/wire is used to transmit data. Note: for .logicdata files, only Saleae version 1 can be used.About Communication ProtocolsIf you are only concerned with the solution and already have some basic knowledge of hardware protocols, feel free to skip this section.Since this challenge is in the IoT category, I figured I should provide a brief background about communication protocols. In order for 2 devices to send data to each other, a protocol has to be established, similar to typical network transmission protocols, but at a hardware level. Usually, the data line is digital (0 or 1). This is true for this challenge as the data being sent is “light communication”.Examples of common protocols are Serial UART and I2C (pronounced I-squared-C). You can read up on them on your own. But most of them have a pretty standard format: header, address (if more than 2 devices), message length, message. This forms the basis of my initial solution.Coming from a robotics background, I am familiar with hardware protocols, even coding one based off the I2C protocol recently. I will discuss 2 key ideas that are seen in many protocols: Clocks and packet structures.In every data transmission, in order to differentiate multiple consecutive bits of the same value (e.g. 1111) a clock is usually established. In systems with more than 1 wire, the clock line (SCL in I2C or CLK) alternates between 0 and 1. Since the system given uses 1 wire, there must be a fixed clock rate, making it easier to read our data as we do not have to worry about rising and falling edges on our clock line.There is also typically a fixed packet structure. In I2C, it is &lt;packet header&gt;&lt;address&gt;&lt;length&gt;&lt;data&gt;  The header can simply be a HIGH signal to start the data transmission  Addresses are used in systems with multiple devices  Length is the string length of the data. Alternatively, some systems may prefer a fixed packet length or a terminator (fixed string to determine end of sequence)My Initial SolutionIf you are uninterested in my failed almost unimportant attempts, skip this section. However, note that skipping this section also assumes you have used the Saleae software before or can figure it out on your own.Of course, the easiest way to start this challenge is to try all the different analyzers (right panel). That didn’t work. So I proceeded to analyze the data packets manually.As seen below, each packet begins with a long HIGH, a long LOW, followed by a sequence of HIGHs and LOWs of fixed width (clock timing has been established). It is interesting to note how a HIGH also has LOWs beside it which does not occur in many protocols.Scrolling in on each HIGH reveals that it is an oscillating signal, making it even harder for certain analyzers to read.Thus, I decided to write a python script to parse the data. The data can be exported to via options &gt; Export data. I assumed the following to be the headers (including addresses): &lt;long HIGH&gt;&lt;long LOW&gt;1111111110101010101010101. Anything after would form the data. I then interpreted the data. For the above image, it would’ve been 101011101010110111. I also assumed a fixed packet length, padding each packet to a multiple of 8 bits. However, converting this to ASCII didn’t work, even if I used a 7-bit ASCII instead.It was at this point I realized my approach was probably wrong. The challenge must be telling something else.The Real SolutionIt dawned upon me that light protocol could refer to an infrared light protocol (NEC IR). I googled about the NEC IR protocol and out came this image.Bingo! This looks EXACTLY like what we are given!In each NEC IR packet, the value of each bit is determined by the time between 2 HIGHs. A long 9ms HIGH and 4.5ms LOW signals the start. Followed by the address and its logical inverse, and then the data and its logical inverse for verification.The Saleae Logic Analyzer software does not officially support the NEC IR protocol so if I wanted to use the software’s analyzer, I would’ve had to download the Saleae SDK and import a library. I also figured that since each “HIGH” contains multiple oscillations of HIGHs and LOWs, this may introduce errors. Instead, we can export the data to a CSV and use a Python script to decode the data whilst ignoring the “noise”.In addition, we notice that the last quarter of the data packets given are not an exact logical inverse of the 3rd quarter. This means the data in our capture does not exactly correspond to the original NEC IR specifications. So perhaps using a script to parse this data is simpler than trying to make an existing analyzer work.Using the Python script below, the bits of the data can be extracted including the headers and addresses. Thresholds for headers and timings between bits could be empirically derived from Saleae in case the transmission does not directly correspond to the original NEC IR specifications.import pandas as pd# Empirically determined timings for 0s and 1szeroTime=0.0005698 oneTime=0.001725df = pd.read_csv(&#39;raw.csv&#39;)outstr = &#39;&#39;prevT = 0prevX = 0prevOne=0first = Truethreshold = (zeroTime+oneTime)/2print &quot;Threshold:&quot;,thresholdfor index, row in df.iterrows():	t = row[&#39;t&#39;]-prevT	if t &gt; 0.0001: #Ignoring noise where gap between 2 HIGHs less than 0.1ms		if t &gt; 0.5: #If gap between 2 HIGHs is more than 500ms, start next packet (ie next line in output string)			if not first: outstr += &#39;\n&#39;					first = False			else:	#When a valid HIGH is detected, determine the value of the bit based on the time between the two			if prevX==0:				outstr+= &#39;1&#39; if t&gt;threshold else &#39;0&#39;	prevT = row[&#39;t&#39;]	prevX = row[&#39;x&#39;]#Save output string to filewith open(&#39;out.txt&#39;,&#39;w&#39;) as f:	f.write(outstr)The output of the above script produces a text file including headers and addresses. The block below only contains one of 6 repeated instances - the message was sent 6.5 times.100000000111111110000000000000000100000000111111110000000000000000100000000111111110110011101101111100000000111111110111011001110100100000000111111110110010101100011100000000111111110110100000101101100000000111111110110001101110011100000000111111110110011101111011100000000111111110100001101010100100000000111111110110011001011111100000000111111110100100101010010100000000111111110101111101001110100000000111111110100010101000011100000000111111110101111100110010100000000111111110011000001000000100000000111111110011000000100001100000000111111110101111101111101Since the address and its logical inverse is consistent throughout (only 1 destination address), the header, address and inverse address can be removed. I used a simple find and replace in a text editor to remove 10000000011111111. The first 2 lines can also be excluded since they are null bytes.011001110110111101110110011101000110010101100011011010000010110101100011011100110110011101111011010000110101010001100110010111110100100101010010010111110100111001000101010000110101111100110010001100000100000000110000001000010101111101111101Copying the above text into a binary to ASCII converter, we obtain the flag govtech-csg{CTf_IR_NEC_20@0!_}, except for an extra ‘_’ which could’ve been added to make the string a multiple of 2 characters.Flag: govtech-csg{CTf_IR_NEC_20@0!}">
    <meta itemprop="datePublished" content="December 12, 2020">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">COVID’s Communication Technology! [984]
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  6 minute read
</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#challenge-description">Challenge Description</a></li>
  <li><a href="#initial-analysis">Initial Analysis</a></li>
  <li><a href="#about-communication-protocols">About Communication Protocols</a></li>
  <li><a href="#my-initial-solution">My Initial Solution</a></li>
  <li><a href="#the-real-solution">The Real Solution</a></li>
</ul>
            </nav>
          </aside>
        
        <p><strong>Category:</strong> Internet of Things (IoT)</p>

<h2 id="challenge-description">Challenge Description</h2>
<blockquote>
  <p>We heard a rumor that COVID was leveraging that smart city’s ‘light’ technology for communication. Find out in detail on the technology and what is being transmitted.</p>
</blockquote>

<h2 id="initial-analysis">Initial Analysis</h2>
<p>We are given a <code class="language-plaintext highlighter-rouge">.logicdata</code> file. After some research, we find that it is a capture output from a Saleae logic analyzer. Essentially, the deivce logs the output of digital/analog pins.</p>

<p>From the challenge description, we know that it is a communication between 2 devices.</p>

<p>Opening the file in the <a href="https://support.saleae.com/logic-software/legacy-software/latest-stable-release-download">Saleae Logic Analyzer software</a> (hence forth referred to as Saleae), we find that only a single channel/wire is used to transmit data. Note: for <code class="language-plaintext highlighter-rouge">.logicdata</code> files, only Saleae version 1 can be used.</p>

<p><img src="https://i.imgur.com/rbRSi3Z.png" alt="" /></p>

<h2 id="about-communication-protocols">About Communication Protocols</h2>
<p>If you are only concerned with the solution and already have some basic knowledge of hardware protocols, feel free to skip this section.</p>

<p>Since this challenge is in the IoT category, I figured I should provide a brief background about communication protocols. In order for 2 devices to send data to each other, a protocol has to be established, similar to typical network transmission protocols, but at a hardware level. Usually, the data line is digital (0 or 1). This is true for this challenge as the data being sent is “light communication”.</p>

<p>Examples of common protocols are Serial UART and I2C (pronounced I-squared-C). You can read up on them on your own. But most of them have a pretty standard format: header, address (if more than 2 devices), message length, message. This forms the basis of my initial solution.</p>

<p>Coming from a robotics background, I am familiar with hardware protocols, even <a href="https://github.com/jloh02/SICC">coding one based off the I2C protocol recently</a>. I will discuss 2 key ideas that are seen in many protocols: Clocks and packet structures.</p>

<p>In every data transmission, in order to differentiate multiple consecutive bits of the same value (e.g. <code class="language-plaintext highlighter-rouge">1111</code>) a clock is usually established. In systems with more than 1 wire, the clock line (SCL in I2C or CLK) alternates between 0 and 1. Since the system given uses 1 wire, there must be a fixed clock rate, making it easier to read our data as we do not have to worry about rising and falling edges on our clock line.</p>

<p>There is also typically a fixed packet structure. In I2C, it is <code class="language-plaintext highlighter-rouge">&lt;packet header&gt;&lt;address&gt;&lt;length&gt;&lt;data&gt;</code></p>
<ul>
  <li>The header can simply be a HIGH signal to start the data transmission</li>
  <li>Addresses are used in systems with multiple devices</li>
  <li>Length is the string length of the data. Alternatively, some systems may prefer a fixed packet length or a terminator (fixed string to determine end of sequence)</li>
</ul>

<h2 id="my-initial-solution">My Initial Solution</h2>
<p>If you are uninterested in my failed almost unimportant attempts, skip this section. However, note that skipping this section also assumes you have used the Saleae software before or can figure it out on your own.</p>

<p>Of course, the easiest way to start this challenge is to try all the different analyzers (right panel). That didn’t work. So I proceeded to analyze the data packets manually.</p>

<p>As seen below, each packet begins with a long HIGH, a long LOW, followed by a sequence of HIGHs and LOWs of fixed width (clock timing has been established). It is interesting to note how a HIGH also has LOWs beside it which does not occur in many protocols.</p>

<p><img src="https://i.imgur.com/XDPH9nv.png" alt="" /></p>

<p>Scrolling in on each HIGH reveals that it is an oscillating signal, making it even harder for certain analyzers to read.</p>

<p><img src="https://i.imgur.com/AazRe8w.png" alt="" /></p>

<p>Thus, I decided to write a python script to parse the data. The data can be exported to via <code class="language-plaintext highlighter-rouge">options &gt; Export data</code>. I assumed the following to be the headers (including addresses): <code class="language-plaintext highlighter-rouge">&lt;long HIGH&gt;&lt;long LOW&gt;1111111110101010101010101</code>. Anything after would form the data. I then interpreted the data. For the above image, it would’ve been <code class="language-plaintext highlighter-rouge">101011101010110111</code>. I also assumed a fixed packet length, padding each packet to a multiple of 8 bits. However, converting this to ASCII didn’t work, even if I used a 7-bit ASCII instead.</p>

<p>It was at this point I realized my approach was probably wrong. The challenge must be telling something else.</p>

<h2 id="the-real-solution">The Real Solution</h2>
<p>It dawned upon me that light protocol could refer to an infrared light protocol (NEC IR). I googled about the NEC IR protocol and out came this image.</p>

<p><img src="https://i.imgur.com/l32xeKe.png" alt="" /></p>

<p>Bingo! This looks EXACTLY like what we are given!</p>

<p>In each NEC IR packet, the value of each bit is determined by the time between 2 HIGHs. A long 9ms HIGH and 4.5ms LOW signals the start. Followed by the address and its logical inverse, and then the data and its logical inverse for verification.</p>

<p>The Saleae Logic Analyzer software does not officially support the NEC IR protocol so if I wanted to use the software’s analyzer, I would’ve had to download the Saleae SDK and import a <a href="https://github.com/LiveOverflow/NECAnalyzer">library</a>. I also figured that since each “HIGH” contains multiple oscillations of HIGHs and LOWs, this may introduce errors. Instead, we can export the data to a CSV and use a Python script to decode the data whilst ignoring the “noise”.</p>

<p><img src="https://i.imgur.com/AazRe8w.png" alt="" /></p>

<p>In addition, we notice that the last quarter of the data packets given are not an exact logical inverse of the 3rd quarter. This means the data in our capture does not exactly correspond to the original NEC IR specifications. So perhaps using a script to parse this data is simpler than trying to make an existing analyzer work.</p>

<p><img src="https://i.imgur.com/XDPH9nv.png" alt="" /></p>

<p>Using the Python script below, the bits of the data can be extracted including the headers and addresses. Thresholds for headers and timings between bits could be empirically derived from Saleae in case the transmission does not directly correspond to the original NEC IR specifications.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Empirically determined timings for 0s and 1s
</span><span class="n">zeroTime</span><span class="o">=</span><span class="mf">0.0005698</span> 
<span class="n">oneTime</span><span class="o">=</span><span class="mf">0.001725</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'raw.csv'</span><span class="p">)</span>

<span class="n">outstr</span> <span class="o">=</span> <span class="s">''</span>
<span class="n">prevT</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">prevX</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">prevOne</span><span class="o">=</span><span class="mi">0</span>
<span class="n">first</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">zeroTime</span><span class="o">+</span><span class="n">oneTime</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="k">print</span> <span class="s">"Threshold:"</span><span class="p">,</span><span class="n">threshold</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="p">.</span><span class="n">iterrows</span><span class="p">():</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s">'t'</span><span class="p">]</span><span class="o">-</span><span class="n">prevT</span>
	<span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="p">:</span> <span class="c1">#Ignoring noise where gap between 2 HIGHs less than 0.1ms
</span>		<span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span> <span class="c1">#If gap between 2 HIGHs is more than 500ms, start next packet (ie next line in output string)
</span>			<span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span> <span class="n">outstr</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span>		
			<span class="n">first</span> <span class="o">=</span> <span class="bp">False</span>	
		<span class="k">else</span><span class="p">:</span>	<span class="c1">#When a valid HIGH is detected, determine the value of the bit based on the time between the two
</span>			<span class="k">if</span> <span class="n">prevX</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
				<span class="n">outstr</span><span class="o">+=</span> <span class="s">'1'</span> <span class="k">if</span> <span class="n">t</span><span class="o">&gt;</span><span class="n">threshold</span> <span class="k">else</span> <span class="s">'0'</span>
	<span class="n">prevT</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s">'t'</span><span class="p">]</span>
	<span class="n">prevX</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s">'x'</span><span class="p">]</span>

<span class="c1">#Save output string to file
</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'out.txt'</span><span class="p">,</span><span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
	<span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">outstr</span><span class="p">)</span>
</code></pre></div></div>

<p>The output of the above script produces a text file including headers and addresses. The block below only contains one of 6 repeated instances - the message was sent 6.5 times.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>100000000111111110000000000000000
100000000111111110000000000000000
100000000111111110110011101101111
100000000111111110111011001110100
100000000111111110110010101100011
100000000111111110110100000101101
100000000111111110110001101110011
100000000111111110110011101111011
100000000111111110100001101010100
100000000111111110110011001011111
100000000111111110100100101010010
100000000111111110101111101001110
100000000111111110100010101000011
100000000111111110101111100110010
100000000111111110011000001000000
100000000111111110011000000100001
100000000111111110101111101111101
</code></pre></div></div>

<p>Since the address and its logical inverse is consistent throughout (only 1 destination address), the header, address and inverse address can be removed. I used a simple find and replace in a text editor to remove <code class="language-plaintext highlighter-rouge">10000000011111111</code>. The first 2 lines can also be excluded since they are null bytes.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0110011101101111
0111011001110100
0110010101100011
0110100000101101
0110001101110011
0110011101111011
0100001101010100
0110011001011111
0100100101010010
0101111101001110
0100010101000011
0101111100110010
0011000001000000
0011000000100001
0101111101111101
</code></pre></div></div>

<p>Copying the above text into a <a href="https://www.rapidtables.com/convert/number/ascii-hex-bin-dec-converter.html">binary to ASCII converter</a>, we obtain the flag <code class="language-plaintext highlighter-rouge">govtech-csg{CTf_IR_NEC_20@0!_}</code>, except for an extra ‘_’ which could’ve been added to make the string a multiple of 2 characters.</p>

<p><strong>Flag:</strong> <code class="language-plaintext highlighter-rouge">govtech-csg{CTf_IR_NEC_20@0!}</code></p>

        
      </section>

      <footer class="page__meta">
        
        


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-12-12T00:00:00+08:00">December 12, 2020</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=COVID%27s+Communication+Technology%21+%5B984%5D%20http%3A%2F%2Flocalhost%3A4000%2FCOVID%27s-Communication-Technology%21%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2FCOVID%27s-Communication-Technology%21%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2FCOVID%27s-Communication-Technology%21%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/An-invitation/" class="pagination--pager" title="An invitation [981]
">Previous</a>
    
    
      <a href="/Can-COViD-steal-Bob's-idea/" class="pagination--pager" title="Can COViD steal Bob’s idea? [960]
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/blog/CVE-2021-33760/" rel="permalink">CVE-2021-33760
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  3 minute read
</p>
    
    <p class="archive__item-excerpt" itemprop="description">Windows Media Foundation Out-of-Bounds Read Vulnerability (mfsrcsnk.dll)
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/ctf/DSO-NUS-CTF-2021/" rel="permalink">DSO-NUS CTF 2021
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  15 minute read
</p>
    
    <p class="archive__item-excerpt" itemprop="description">A local Singaporean CTF hosted by DSO National Laboratories and the National University of Singapore (NUS). I played this CTF with my regular teammate, @Ocea...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/blog/Binary-Exploitation-Techniques/" rel="permalink">Binary Exploitation Techniques
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  6 minute read
</p>
    
    <p class="archive__item-excerpt" itemprop="description">Stack and Heap exploitation techniques for pwn challenges in CTFs.
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/blog/Binary-Exploitation-Cheatsheet/" rel="permalink">Binary Exploitation Cheatsheet
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read
</p>
    
    <p class="archive__item-excerpt" itemprop="description">Some notes for pwn challenges in CTFs.
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://milotruck.github.io" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i> Blog</a></li>
        
      
        
      
        
      
        
          <li><a href="https://github.com/MiloTruck" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 MiloTruck. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
